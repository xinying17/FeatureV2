{
    "contents" : "network_features <- function(L='label',data_train,data_test,nf,p,corr,f_type,s,nc)\n{\n  classes <- unique(data_train$label)\n\n  names(data_train)[colnames(data_train)==L] <- paste(\"label\")\n  names(data_test)[colnames(data_test)==L] <- paste(\"label\")\n\n  data_trainm <- data_train[,colnames(data_train)!=L]\n  data_testm <- data_test[,colnames(data_test)!=L]\n\n  train_label <- data_train$label\n  test_label <- data_test$label\n\n  # feature selection\n  if(nf>0) {\n    nf = round(min(ncol(data_train),nf))\n\n    # rank feature by ttest\n    indx <- rankfeature(L,data_train,classes,nf)\n    train_label <- data_train[,colnames(data_train)==L]\n    data_trainm <- data_trainm[,indx]\n    test_label <- data_test[,colnames(data_test)==L]\n    data_testm <- data_testm[,indx]\n\n  }\n\n  # build network for each class\n  if(f_type<3){\n    train_nets <- data.frame(\"I\"=c(1:2))\n    rownames(train_nets) <- c(\"network\",\"laplacian\")\n    for(t in classes){\n      class_train <- subset(data_train,label==t)\n      class_train_data <- class_train[indx,colnames(class_train)!=L]\n      nets <- network_build(class_train_data, p, corr)\n      train_nets$t <- nets\n      train_nets$data <- class_train_data\n      names(train_nets)[names(train_nets)=='t'] <- t\n    }\n\n    # new features\n    new_train = NULL\n    new_test = NULL\n    if(f_type==1){ # new features with different power of laplacian matrix\n      for(t in classes){\n        nets <- train_nets[,t]\n\n        r <- eigen(nets$laplacian)\n        V <- r$vectors\n        lam <- r$values\n        lam[lam<0] = 0\n        Lmbd = diag(lam ** abs(s))\n        if(s<0){\n          Lmbd = ginv(Lmbd)\n        }\n        newL = V %*% Lmbd %*% solve(V)\n        new_train <- cbind(new_train,as.matrix(data_trainm) %*% newL)\n        new_test <- cbind(new_test,as.matrix(data_testm) %*% newL)\n      }\n    }\n\n    if(f_type==2){ # single network intergration value\n      for(t in classes){\n        nets <- train_nets[,t]\n\n        r <- eigen(nets$laplacian)\n        V <- r$vectors\n        lam <- r$values\n        lam[lam<0] = 0\n        Lmbd = diag(lam)\n        newL = V %*% Lmbd %*% solve(V)\n        lap_fun <- function(x) {x %*% newL %*% x}\n        smooth_value <- apply(f, 1, lap_fun)\n\n        new_train <- cbind(new_train,apply(as.matrix(data_trainm),1,lap_fun))\n        new_test <- cbind(new_test,apply(as.matrix(data_testm),1,lap_fun))\n      }\n    }\n  }\n\n  if(f_type==3){ # subnetwork integration value\n    # build network for each class\n    aa = 1\n    for(t in classes){\n      class_train <- subset(data_train,label==t)\n      class_train_data <- class_train[indx,colnames(class_train)!=L]\n      clusters <- hclust(dist(t(as.matrix(class_train_data))),method = \"ward.D\")\n      clusterCut <- cutree(clusters, nc)\n      for(i in 1:nc){\n        x = data.frame(class_train_data[,clusterCut==i])\n        if(ncol(x)>1){\n          nets <- network_build(as.matrix(x), p, corr)\n          train_nets$types[[aa]] <- t\n          train_nets$featureIDX[[aa]] <- colnames(x)\n          train_nets$nets[[aa]] <- nets\n          aa = aa+1\n        }\n      }\n\n    }\n    new_train <- matrix(nrow = nrow(data_train),ncol = length(train_nets$types))\n    new_test <- matrix(nrow = nrow(data_test),ncol = length(train_nets$types))\n\n    # new train data\n    for(b in 1:length(train_nets$types)){\n      nets <- train_nets$nets[[b]]\n      smooth_value <- smoothness(Lap = nets$laplacian,\n                                 data_train[,train_nets$featureIDX[[b]]],s)\n      new_train[,b] <- smooth_value\n    }\n\n    # new test data\n    for(b in 1:length(train_nets$types)){\n      nets <- train_nets$nets[[b]]\n      smooth_value <- smoothness(nets$laplacian,\n                                 data_test[,train_nets$featureIDX[[b]]],s)\n      new_test[,b] <- smooth_value\n    }\n  }\n\n\n  new_train <- t(scale(t(new_train)))\n  new_train <- data.frame(new_train)\n  new_test <- t(scale(t(new_test)))\n  new_test <- data.frame(new_test)\n\n  # remove na and inf\n  is.na(new_train) <- sapply(new_train, is.infinite)\n  is.na(new_train) <- sapply(new_train, is.nan)\n  ind_na <- colSums(is.na(new_train))==0\n  new_train <- new_train[,ind_na]\n  new_test <- new_test[,ind_na]\n\n  return(list(new_train = new_train, new_test = new_test, train_label = train_label, test_label = test_label))\n\n}\n\nsmoothness <- function(Lap,f,s){\n  # f is the function vector\n  # s is parameter on Laplacian function\n  f <- as.matrix(f)\n  require('expm', quietly = TRUE)\n  require('matrixcalc',quietly = TRUE)\n  # if(is.positive.definite(Lap,tol=0)){\n  #lap_fun <- function(x) {x %*% expm(s*logm(as.matrix(Lap))) %*% x}\n  r <- eigen(Lap)\n  V <- r$vectors\n  lam <- r$values\n  lam[lam<0] = 0\n  Lmbd = diag(lam ** s)\n  newL = V %*% Lmbd %*% solve(V)\n  lap_fun <- function(x) {x %*% newL %*% x}\n\n  smooth_value <- apply(f, 1, lap_fun)\n  return(smooth_value)\n}\n",
    "created" : 1496086571200.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "1828086810",
    "id" : "991151FB",
    "lastKnownWriteTime" : 1496086577,
    "path" : "~/Documents/Rstudio/FeatureV2/R/network_features.R",
    "project_path" : "R/network_features.R",
    "properties" : {
    },
    "relative_order" : 3,
    "source_on_save" : false,
    "type" : "r_source"
}